#include <windows.h>
#include <iostream>
#include <stdlib.h>
#include <time.h>
using namespace std;

/* В Dice2.0 была оптимизация работы программы (чтобы было меньше строк), а сейчас выполним оптимизацию кода (чтобы было удобнее работать с самим кодом, делать обновле-
ния, поддержку и прочее). Раз бросок пирата ничем не отличается от броска корсара, объединим их в одну переменную. Новая переменная strike будет отвечать за то, что вы-
пало на кубике, который мы сперва будем бросать для пирата, а потом для игрока. И генерировать мы будем только strike, а потом, что сгенерировали, на первом шаге цикла
будет передаваться пирату, а на втором - корсару. У нас не будет двух отдельных генераций, а будет дважды сгенерировано число: первая генерация отправится пирату, дру-
гая игроку (для этого и нужна просто переменная strike).
Еще одна корректировка, вложим в цикл do_while определение победителя. Т.к. у нас с этим блоком все хорошо, копируем от определения победителя и до конца в наш код. А
цикл самой игры будет немного другим. Раньше подготовкой к игре являлась очистка экрана, т.к. cash мы вводили единажды и больше не трогали, плюсовали либо минусовали
ставку. bet мы каждый раз вводили с клавиатуры вручную (тоже не нужно было как-то ее изменять перед новой игрой, т.к. мы ее сперва вводили, а потом анализировали).
Броски карсара и пирата мы тоже сперва бросали, а потом сравнивали. А теперь бросаться будет лишь strike (ГСЧ для этой переменной работать будет). Броски пирата и кор-
сара будут получать значения strike, след, перед началом новой игры броски игрока и компьютера необходимо обнулить.
(!) в каждой программе с реиграбельностью нужно подготавливать те переменные и те объекты, которые нужны для новой игры, но если они и так будут изменяться в ее процес-
се, то это не обязательно. Но раз уж мы говорим что это нужно сделать, сделаем. Обязательно нужно обнулить броски пирата и корсара, остальные не обязательно.

И вот перед определением победителя мы цикл for вставим и в нем попробуем сделать чтобы switch был лишь единожды. Цикл из двух бросков.
1-е - бросаем кубик (один на обоих). На экране они отличались также фразами и цифрами. Мы запишем что то, что сейчас выпадет на кубике будет принадлежать пирату
strike_pc = strike.
И теперь, когда мы нужную цифру поместили в нужное хранилище, будет один единственный switch для strike. До этого мы рисовали бросок пирата и карсара, а теперь мы будем
рисовать кубик.
Если же кубик должен рисоваться для них по-разному, такой оптимизации уже не будет.
Если после броска Пирата и Корсара будет ничья, надо вывести ее на экран и перебросить. А также обновить счетчик. Если бы у нас был какой-нибудь цикл while или do_while
мы бы просто написали i=0, а в цикле for i++ находится в параметрах цикла и увеличится в люб.случае, поэтому мы установим его после всех необходимых действий при ничье
в положение на 1 меньше начального (если начальное положение 1, то ставим 0. Если начальное положение 0, ставим -1). Т.о. прибавление на 1 автоматически произойдет и
снова бросит пират, переброс состоится! */

int main()
{
    SetConsoleOutputCP(1251);
    srand((unsigned int)time(NULL)); // напишем сюда явное преобразование, необязательно, но для студии понятнее
    cout << "----------------------------------------------------------Корсары! Игра в кости!-----------------------------------------------------------------" << endl;
    int cash = 0, bet = 0, strike_pc = 0, strike_player = 0, strike = 0;

    do
    {
        cout << "Внеси деньги на бочку! "; cin >> cash;
        if (cash < 0)cout << "Хаp! Карманы дырявые, нищее отребье!" << endl;
    } while (cash < 0);

    if (cash == 0)
        cout << "Хаp! Кошелек прохудился! Давай-ка проваливай!" << endl;
    else
    {
        do  // цикл самой игры
        {
            // обнуление переменных перед новой игрой
            strike_pc = 0;
            strike_player = 0;
            // необязательно
            strike = 0;
            bet = 0;

            // далее идет механизм ставки
            system("cls");
            cout << "------Деньги на бочку!------" << endl;
            cout << "В мешочке осталось: " << cash << " пиастров!" << endl;

            do
            {
                cout << "Сколько ставишь? "; cin >> bet;
                if (bet < 0)cout << "Агрх! С баблом что худо..? Корабль ставишь?" << endl;
                if (bet > cash)cout << "Агрх, разрази меня гром! Жизнью решил/а расплатиться?" << endl;
            } while (bet<0 || bet>cash);

            if (bet == 0)
            {
                cout << "Агрх, крыса помойная! Учапывай давай отсюда!" << endl;
                break;
            }
            else
            {
                for (int i = 1; i <= 2; i++)                        // цикл из двух бросков (i==1 - бросок пирата, i==2 - бросок игрока)
                {
                    strike = rand() % 6 + 1;                        // делаем бросок кубика
                    if (i == 1)                                     // бросок пирата
                    {
                        strike_pc = strike;                         // присваиваем значение, выпавшее на кубике, броску пирата
                        cout << "У пирата выпало: ";
                    }
                    else                                            // бросок игрока
                    {
                        strike_player = strike;                     // присваиваем значение, выпавшее на кубике, броску игрока
                        cout << "\nУ корсара выпало: ";
                    }
                    switch (strike)             // не важно чей будет бросок, кубик рисуется одинаково
                    {
                    case 1:
                        cout << R"(
 _ _ _      
|     |
|  *  |
|_ _ _|
)";
                        break;
                    case 2:
                        cout << R"(
 _ _ _
|   * |
|     |
|_*_ _|
)";
                        break;
                    case 3:
                        cout << R"(
 _ _ _
|   * |
|  *  |
|_*_ _|
)";
                        break;
                    case 4:
                        cout << R"(
 _ _ _
| * * |
|     |
|_*_*_|
)";
                        break;
                    case 5:
                        cout << R"(
 _ _ _
| * * |
|  *  |
|_*_*_|
)";
                        break;
                    case 6:
                        cout << R"(
 _ _ _
| * * |
| * * |
|_*_*_|
)";
                        break;

                    }
                    if (strike_pc == strike_player)                   // если после броска Пирата и Корсара ничья
                    {
                        cout << "\nАгрх, перекинем!\n" << endl;
                        // обнуляем броски Пирата и Корсара
                        strike_pc = 0;
                        strike_player = 0;
                        i = 0;                                      // устанавливаем счетчик на значение перед броском пирата
                    }
                }
            }
            // Определение победителя
            if (strike_pc > strike_player)
            {
                cout << "Ветер, хар, не в твои паруса дует!" << endl;
                cash -= bet;
                cout << "В мешочке осталось: " << cash << " пиастров!" << endl;
            }
            else
            {
                cout << "Везет тебе чужеземец/ка!" << endl;
                cash += bet;
                cout << "В мешочке набралось: " << cash << " пиастров!" << endl;
            }
            if (cash == 0)
            {
                cout << "Удача, сморю, не на твоей стороне чужестранец/ка! Давай-ка проваливай!" << endl;
                break;
            }
            system("pause");
        } while (cash > 0);
    }
    Sleep(3000);
}
/* Д/З: доработать игру чтобы бросались по 2 кубика один под одним и два рядом! */