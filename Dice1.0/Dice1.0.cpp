#include <windows.h>    // sleep
#include <iostream>
#include <stdlib.h>     // ГСЧ
#include <time.h>       // сдвиг
using namespace std;

/* Напишем игру пиратские кости. Будем играть за корсара против компьютера (пирата). Будем бросать кубики, делать ставки, ставить на кон пиастры. У кого больше выпадет,
выиграет и заберет себе ставку, отнимая ее у проигравшего.

У компьютера будут деньги неограничены. Играть будем до тех пор пока не кончатся деньги у игрока (корсара) или же он не откажется от игры. Пользователь будет отказы-
ваться от игры вводом 0. При одинаковых кубиках будем перекидывать.
Цикл повтора игры будет следующий: мы сперва запросим сколько денег сейчас у карсара и будем играть до тех пор пока он все не проиграет либо не откажется от игры. Если
сразу ввести 0, то корсар откажется от игры. Выход из игры будет возможным при завершении кона.

ГСЧ: если мы напишем %6, то в таком случае у нас выпадут цифры от 0 до 6 (0-5), а 0 нам не нужен, след, мы прибавим 1 и произойдет сдвиг всей последовательности на 1
(от 1 до 7). Математика тут следующая: когда мы говорим %7, это значит с числа, которое нам сгенерирует rand(), мы берем остаток от деления на 7. А остаток от деления
на 7 любого числа это будет либо 0 (когда делится на 7 без остатка), либо числа из диапазона от 1 до 7 (полный диапазон 0-6).
Почему только они? Т.к. при достижении числа 6 в остатке, полный цикл 7-ки будет пройден и далее деление уже снова будет без остатка и так снова и снова от 0 до 7. Лю-
бой величины числа поддаются этой логике. След, %6 ограничивает диапазон до 6, а +1 сдвигает его. След, можно и так сдвинуть, чтобы кубик выдавал только скажем от 4 до
6 для легкого уровня сложности, либо для мухлежей и т.д.

Создадим механизм переброса при ничьей. Перебрасывать надо в цикле, т.к. ничья может быть несколько раз подряд. Тут подойдет цикл while, т.к. мы в него зайдем когда ни-
чья уже случится, а остальные броски пройдум мимо цикла. */

int main()
{
    SetConsoleOutputCP(1251);
    srand(time(NULL));
    cout << "----------------------------------------------------------Корсары! Игра в кости!-----------------------------------------------------------------" << endl;
    int cash = 0, bet = 0, strike_pc = 0, strike_player = 0;

    do
    {
        cout << "Внеси деньги на бочку! "; cin >> cash;
        if (cash < 0)cout << "Хаp! Карманы дырявые, нищее отребье!" << endl;

    } while (cash < 0);

    if (cash == 0)
        cout << "Хаp! Кошелек прохудился! Давай-ка проваливай!" << endl;
    else
    {
        do
        {
            system("cls");                                                                          // очистка экрана перед первой игрой
            cout << "------Деньги на бочку!------" << endl;
            cout << "В мешочке осталось: " << cash << " пиастров!" << endl;                         // сколько у нас денег на игру
            do                                                                                      // время ставок
            {
                cout << "Сколько ставишь пиастров? "; cin >> bet;
                if (bet < 0)
                {
                    cout << "Агрх! с баблом что худо..? Корабль ставишь?" << endl;
                    Sleep(3000);
                    cout << "Корабль..? Скорее отправлю тебя к морскому дьяволу!" << endl;
                    Sleep(3000);
                }
                if (bet > cash)cout << "Агрх, разрази меня гром! Жизнью решил/а расплатиться?" << endl;
            } while (bet<0 || bet>cash);

            if (bet == 0)                                                                            // выход из игры!
            {
                cout << "Агрх! Крыса помойная! Учапывай давай отсюда!" << endl;
                break;
            }
            else                                                                                     // ставка задана
            {
                strike_pc = rand() % 6 + 1;
                strike_player = rand() % 6 + 1;
                cout << "У пирата выпало: ";
                Sleep(3000);
                switch (strike_pc)
                {
                case 1:
                    cout << R"(
 _ _ _
|     |
|  *  |
|_ _ _|
)";
                    break;
                case 2:
                    cout << R"(
 _ _ _
|   * |
|     |
|_*_ _|
)";
                    break;
                case 3:
                    cout << R"(
 _ _ _
|   * |
|  *  |
|_*_ _|
)";
                    break;
                case 4:
                    cout << R"(
 _ _ _
| * * |
|     |
|_*_*_|
)";
                    break;
                case 5:
                    cout << R"(
 _ _ _
| * * |
|  *  |
|_*_*_|
)";
                    break;
                case 6:
                    cout << R"(
 _ _ _
| * * |
| * * |
|_*_*_|
)";
                    break;

                }
                Sleep(3000);
                cout << "\nУ корсара выпало: ";
                Sleep(3000);
                switch (strike_player)
                {
                case 1:
                    cout << R"(
 _ _ _
|     |
|  *  |
|_ _ _|

)";
                    break;
                case 2:
                    cout << R"(
 _ _ _
|   * |
|     |
|_*_ _|

)";
                    break;
                case 3:
                    cout << R"(
 _ _ _
|   * |
|  *  |
|_*_ _|

)";
                    break;
                case 4:
                    cout << R"(
 _ _ _
| * * |
|     |
|_*_*_|

)";
                    break;
                case 5:
                    cout << R"(
 _ _ _
| * * |
|  *  |
|_*_*_|

)";
                    break;
                case 6:
                    cout << R"(
 _ _ _
| * * |
| * * |
|_*_*_|

)";
                    break;

                }
                Sleep(3000);

                while (strike_pc == strike_player)
                {
                    cout << "\nАгрх! перекинем!\n" << endl;
                    strike_pc = rand() % 6 + 1;
                    strike_player = rand() % 6 + 1;
                    cout << "У пирата выпало: ";
                    Sleep(3000);
                    switch (strike_pc)
                    {
                    case 1:
                        cout << R"(
 _ _ _
|     |
|  *  |
|_ _ _|
)";
                        break;
                    case 2:
                        cout << R"(
 _ _ _
|   * |
|     |
|_*_ _|
)";
                        break;
                    case 3:
                        cout << R"(
 _ _ _
|   * |
|  *  |
|_*_ _|
)";
                        break;
                    case 4:
                        cout << R"(
 _ _ _
| * * |
|     |
|_*_*_|
)";
                        break;
                    case 5:
                        cout << R"(
 _ _ _
| * * |
|  *  |
|_*_*_|
)";
                        break;
                    case 6:
                        cout << R"(
 _ _ _
| * * |
| * * |
|_*_*_|
)";
                        break;

                    }
                    Sleep(3000);
                    cout << "\nУ корсара выпало: ";
                    Sleep(3000);
                    switch (strike_player)
                    {
                    case 1:
                        cout << R"(
 _ _ _
|     |
|  *  |
|_ _ _|
)";
                        break;
                    case 2:
                        cout << R"(
 _ _ _
|   * |
|     |
|_*_ _|
)";
                        break;
                    case 3:
                        cout << R"(
 _ _ _
|   * |
|  *  |
|_*_ _|
)";
                        break;
                    case 4:
                        cout << R"(
 _ _ _
| * * |
|     |
|_*_*_|
)";
                        break;
                    case 5:
                        cout << R"(
 _ _ _
| * * |
|  *  |
|_*_*_|
)";
                        break;
                    case 6:
                        cout << R"(
 _ _ _
| * * |
| * * |
|_*_*_|
)";
                        break;

                    }
                    Sleep(3000);
                }

                // Определение победителя
                if (strike_pc > strike_player)
                {
                    cout << "Ветер, хар, не в твои паруса дует!" << endl;
                    cash -= bet;
                    cout << "В мешочке осталось: " << cash << " пиастров!" << endl;
                }
                else
                {
                    cout << "Везет тебе чужеземец/ка!" << endl;
                    cash += bet;
                    cout << "В мешочке набралось: " << cash << " пиастров!" << endl;
                }
                if (cash == 0)
                {
                    cout << "Удача, сморю, не на твоей стороне чужестранец/ка! Прощай!" << endl;
                    break;
                }
                system("pause");
            }
        } while (cash > 0);   // играем до тех пор, пока есть деньги
    }
    Sleep(3000);
}

/* Псевдокод:
1.  Интерфейс пользователя (текст на экране)
2.  Механизм ставок (ввод ставки, проверка ввода, фиксация, прибавление при победе, вычитание при поражении)
3.  Вывод кубиков (отрисовка)
4.  Возможность повторной игры (реиграбельность)
5.  Механизм определения победителя (сравнить что выпало у одного, у второго, сказать что у кого больше тот победил...)
6.  Механизм переброса при ничьей (переброс при ничьей)

Оптимизация:
(!) нельзя писать одинаковые строчки кода, их нужно оптимизировать! Что у нас тут происходит:
У нас идет сначала бросок, мы его выводим на экран, а потом если ничья, мы еще раз перебрасываем до тех пор, пока ничья. Мы берем, бросаем, а потом проверяем нужно ли
еще раз бросить. Мы сначала делаем какое-то действие, набор действий, а потом проверяем нужно ли повторить этот самый набор действий. А логика тут д/б следующая, мы
бросаем, и если ничья, снова бросаем! И тогда мы бы сразу начали броски с цикла do_while. Изначально поместить наши броски в цикл бросков, т.е. не перебрасывать при ни-
чьей. Оптимизация будет выполнена в след.проекте. */